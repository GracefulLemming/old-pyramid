# Copyright 2016 Joel Dunham
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""The forms of an OLD are the collection of Form resources in that OLD."""

from sqlalchemy import Column, Sequence, ForeignKey
from sqlalchemy.types import Integer, Unicode, UnicodeText, Date, DateTime
from sqlalchemy.orm import relation
from .meta import Base, now


class FormFile(Base):
    """The form-file model encodes the many-to-many relationship between
    forms and files.
    """

    __tablename__ = 'formfile'

    id = Column(Integer, Sequence('formfile_seq_id', optional=True), primary_key=True)
    form_id = Column(Integer, ForeignKey('form.id'))
    file_id = Column(Integer, ForeignKey('file.id'))
    datetime_modified = Column(DateTime, default=now)


class FormTag(Base):
    """The form-tag model encodes the many-to-many relationship between
    forms and tags.
    """

    __tablename__ = 'formtag'

    id = Column(Integer, Sequence('formtag_seq_id', optional=True), primary_key=True)
    form_id = Column(Integer, ForeignKey('form.id'))
    tag_id = Column(Integer, ForeignKey('tag.id'))
    datetime_modified = Column(DateTime(), default=now)


class CollectionForm(Base):
    """The collection-form model encodes the many-to-many relationship between
    collections and forms.
    """

    __tablename__ = 'collectionform'

    id = Column(Integer, Sequence('collectionform_seq_id', optional=True), primary_key=True)
    collection_id = Column(Integer, ForeignKey('collection.id'))
    form_id = Column(Integer, ForeignKey('form.id'))
    datetime_modified = Column(DateTime(), default=now)


class Form(Base):
    """A Form is a linguistic form, i.e., a word, morpheme, or sentence. It
    may represent an utterance at a specific time by a particular person or an
    abstract generalization such as a morpheme.
    """

    __tablename__ = "form"

    def __repr__(self):
        return "<Form (%s)>" % self.id

    id = Column(Integer, Sequence('form_seq_id', optional=True),
                primary_key=True)
    UUID = Column(Unicode(36))
    transcription = Column(
        Unicode(510), nullable=False, doc='A transcription of a linguistic'
        ' form, probably orthographic.')
    phonetic_transcription = Column(Unicode(510),
        doc='A narrow phonetic transcription, probably in IPA.')
    narrow_phonetic_transcription = Column(Unicode(510),
        doc='A phonetic transcription, probably in IPA.')
    morpheme_break = Column(Unicode(510),
        doc='A sequence of morpheme shapes and delimiters. The OLD assumes'
        ' phonemic shapes (e.g., “in-perfect”), but phonetic (i.e.,'
        ' allomorphic, e.g., “im-perfect”) ones are ok.')
    morpheme_gloss = Column(Unicode(510),
        doc='A sequence of morpheme glosses and delimiters, isomorphic to the'
        ' morpheme break sequence, e.g., “NEG-parfait”.')
    comments = Column(UnicodeText, doc='General-purpose notes and commentary'
        ' about the form.')
    speaker_comments = Column(UnicodeText, doc='Comments about the form made by'
        ' the speaker/consultant.')
    grammaticality = Column(
        Unicode(255), doc='The grammaticality of the form, e.g., grammatical,'
        ' ungrammatical, questionable, infelicitous in a given context.'
        ' Possible values are defined in the application settings of each OLD.')
    date_elicited = Column(
        Date, doc='The date when a particular form was elicited.')
    datetime_entered = Column(DateTime)
    datetime_modified = Column(DateTime, default=now)
    syntactic_category_string = Column(
        Unicode(510),
        doc='A sequence of categories (and morpheme delimiters) that is'
        ' auto-generated by an OLD based on the morphemes/glosses in the morpheme'
        ' break and morpheme gloss values of a form and the categories of'
        ' matching lexical items in the database.')
    morpheme_break_ids = Column(
        UnicodeText,
        doc='An OLD-generated value that essentially memoizes/caches the forms'
        ' (and their relevant properties) that match the morphemes'
        ' transcriptions/shapes identified in the morpheme break value of a'
        ' form.')
    morpheme_gloss_ids = Column(
        UnicodeText,
        doc='An OLD-generated value that essentially memoizes/caches the forms'
        ' (and their relevant properties) that match the morpheme glosses'
        ' identified in the morpheme break value of a form.')
    break_gloss_category = Column(
        Unicode(1023),
        doc='The morpheme break, morpheme gloss and (syntactic) category string'
        ' values of a form all interleaved into a single string. This value is'
        ' auto-generated by the OLD.')
    syntax = Column(
        Unicode(1023),
        doc='A syntactic phrase structure representation in some kind of'
        ' string-based format.')
    semantics = Column(Unicode(1023),
        doc='A semantic representation of the meaning of the form in some'
        ' string-based format.')
    status = Column(
        Unicode(40), default='tested',
        doc='The status of the form: “tested” for data that have been'
        ' elicited/tested/verified with a consultant or “requires testing”'
        ' for data that are posited and still need testing/elicitation.')
    elicitor_id = Column(Integer, ForeignKey('user.id', ondelete='SET NULL'))
    elicitor = relation(
        'User', primaryjoin='Form.elicitor_id==User.id',
        doc='The linguistic fieldworker who elicited the form with the help of'
        ' the consultant.')
    enterer_id = Column(Integer, ForeignKey('user.id', ondelete='SET NULL'))
    enterer = relation(
        'User', primaryjoin='Form.enterer_id==User.id')
    modifier_id = Column(Integer, ForeignKey('user.id', ondelete='SET NULL'))
    modifier = relation(
        'User', primaryjoin='Form.modifier_id==User.id')
    verifier_id = Column(Integer, ForeignKey('user.id', ondelete='SET NULL'))
    verifier = relation(
        'User', primaryjoin='Form.verifier_id==User.id',
        doc='The person (OLD user) who has verified the reliability/accuracy of'
        ' this form.')
    speaker_id = Column(Integer, ForeignKey('speaker.id', ondelete='SET NULL'))
    speaker = relation(
        'Speaker',
        doc='The speaker (consultant) who produced or judged the form.')
    elicitationmethod_id = Column(
        Integer, ForeignKey('elicitationmethod.id', ondelete='SET NULL'))
    elicitation_method = relation(
        'ElicitationMethod',
        doc='How a linguistic form was elicited. Examples: “volunteered”,'
        ' “judged elicitor’s utterance”, “translation task”, etc.')
    syntacticcategory_id = Column(
        Integer, ForeignKey('syntacticcategory.id', ondelete='SET NULL'))
    syntactic_category = relation(
        'SyntacticCategory', backref='forms',
        doc='The category (syntactic or morphological) of the form.')
    source_id = Column(Integer, ForeignKey('source.id', ondelete='SET NULL'))
    source = relation(
        'Source',
        doc='The textual source (e.g., research paper, text collection, book of'
        ' learning materials) from which the form was drawn, if applicable.')
    translations = relation(
        'Translation', backref='form', cascade='all, delete, delete-orphan',
        doc='The translations for the form. Each translation may have its own'
        ' grammaticality/acceptibility specification indicating whether it is'
        ' an acceptable translation for the given form.')
    files = relation(
        'File', secondary=FormFile.__table__, backref='forms',
        doc='The digital files (e.g., audio, video, image or text) that are'
        ' associated to a given form.')
    collections = relation(
        'Collection', secondary=CollectionForm.__table__, backref='forms',
        doc='The collections, i.e., texts (e.g., papers, elicitation records,'
        ' etc.), that a given form is a part of.')
    tags = relation(
        'Tag', secondary=FormTag.__table__, backref='forms')

    corpora_doc = 'The set of corpora that an OLD form belongs to.'
    memorizers_doc = (
        'The set of OLD user resources that currently have a particular OLD'
        ' form in their set of remembered forms.')

    def get_dict(self):
        """Return a Python dictionary representation of the Form.  This
        facilitates JSON-stringification, cf. utils.JSONOLDEncoder.  Relational
        data are truncated, e.g., form_dict['elicitor'] is a dict with keys for
        'id', 'first_name' and 'last_name' (cf. get_mini_user_dict above) and lacks
        keys for other attributes such as 'username', 'personal_page_content', etc.
        """

        return {
            'id': self.id,
            'UUID': self.UUID,
            'transcription': self.transcription,
            'phonetic_transcription': self.phonetic_transcription,
            'narrow_phonetic_transcription': self.narrow_phonetic_transcription,
            'morpheme_break': self.morpheme_break,
            'morpheme_gloss': self.morpheme_gloss,
            'comments': self.comments,
            'speaker_comments': self.speaker_comments,
            'grammaticality': self.grammaticality,
            'date_elicited': self.date_elicited,
            'datetime_entered': self.datetime_entered,
            'datetime_modified': self.datetime_modified,
            'syntactic_category_string': self.syntactic_category_string,
            'morpheme_break_ids': self.json_loads(self.morpheme_break_ids),
            'morpheme_gloss_ids': self.json_loads(self.morpheme_gloss_ids),
            'break_gloss_category': self.break_gloss_category,
            'syntax': self.syntax,
            'semantics': self.semantics,
            'status': self.status,
            'elicitor': self.get_mini_user_dict(self.elicitor),
            'enterer': self.get_mini_user_dict(self.enterer),
            'modifier': self.get_mini_user_dict(self.modifier),
            'verifier': self.get_mini_user_dict(self.verifier),
            'speaker': self.get_mini_speaker_dict(self.speaker),
            'elicitation_method': self.get_mini_elicitation_method_dict(self.elicitation_method),
            'syntactic_category': self.get_mini_syntactic_category_dict(self.syntactic_category),
            'source': self.get_mini_source_dict(self.source),
            'translations': self.get_translations_list(self.translations),
            'tags': self.get_tags_list(self.tags),
            'files': self.get_files_list(self.files)
        }

    def extract_word_pos_sequences(self, unknown_category, morpheme_splitter,
                                   extract_morphemes=False):
        """Return the unique word-based pos sequences, as well as (possibly)
        the morphemes, implicit in the form.

        :param str unknown_category: the string used in syntactic category
            strings when a morpheme-gloss pair is unknown
        :param morpheme_splitter: callable that splits a strings into its
            morphemes and delimiters
        :param bool extract_morphemes: determines whether we return a list of
            morphemes implicit in the form.
        :returns: 2-tuple: (set of pos/delimiter sequences, list of morphemes
            as (pos, (mb, mg)) tuples).
        """
        if not self.syntactic_category_string:
            return None, None
        pos_sequences = set()
        morphemes = []
        sc_words = self.syntactic_category_string.split()
        mb_words = self.morpheme_break.split()
        mg_words = self.morpheme_gloss.split()
        for sc_word, mb_word, mg_word in zip(sc_words, mb_words, mg_words):
            pos_sequence = tuple(morpheme_splitter(sc_word))
            if unknown_category not in pos_sequence:
                pos_sequences.add(pos_sequence)
                if extract_morphemes:
                    morpheme_sequence = morpheme_splitter(mb_word)[::2]
                    gloss_sequence = morpheme_splitter(mg_word)[::2]
                    for pos, morpheme, gloss in zip(pos_sequence[::2], morpheme_sequence, gloss_sequence):
                        morphemes.append((pos, (morpheme, gloss)))
        return pos_sequences, morphemes

